# Top-down programming for problem solving

&nbsp;

&nbsp;

&nbsp;

<div style="text-align: center"><b>Hui Chong</b><br/><br/>
Email: <a href="mailto:huichong.me@gmail.com">huichong.me@gmail.com<a><br/>
Website: <a href="https://www.huichong.me">https://www.huichong.me</a>
</div>

&nbsp;

&nbsp;

<div style="text-align: right">May 9, 2022<br/>
Big Data Biology Lab, <br/>
Institute of Science and Technology for Brain-inspired Intelligence, <br/>
Fudan University
</div>
---
## Programming for problem solving

### Why programming?

There are generally two ways to solve problems.

#### Manual operation

- Flexible: human can adapt to different problems.
- Error prone: human can make random mistakes.
- **But, what if you have to execute your solution over and over again in the future?**
- Human are **not** for those repetitive works.

#### Programming

- Less flexible: a program is built for only one kind of problems.
- **Easy to scale up**: It's just a series of pre-defined instructions to be executed by computers.

Not all problems can be solved by programming.

---
## Top-down programming & bottom-up debugging

### What are the benefits?

- Clear code structure that is easy to understand by others.
- Coding is also a kind of commuication (e.g., collaborative developing).
- Easier to debug.
- Develop and test more efficiently without almost any extra cost.
- Top-down programming is independent of programming language. 


### How it works? 

- Split each problem into multiple sub-problems.
- Solve each sub-problem independently.
- Then, assemble solutions to these sub-problems from the bottom-up.

---


## Function call graph

Function call graph can clearly show the structure of you program.

![](example/complex.png)

The example was generated by the [PyCallGraph](https://pycallgraph.readthedocs.io/en/master/index.html) package.

---
## How to apply top-down programming?

- Think about the structure while/before you write code.
- The main function goes on the top so that any new comer can see the structure of the script (like a **table of content**).
- Run `main()` inside `if __name__ == '__main__'` statement for easier test.
  - `main()` function will not be executed if you're importing the script.

```python
def main():
    A(xxx)
    B(xxx)
    C(xxx)

def A(xxx):
    D(xxx)
    E(xxx)

......

def I(xxx):
  ......

if __name__ == '__main__':  
    main()
```

Programming is also about debugging, but how to?

---
## Bottom-up debugging and error analysis

If a module cannot work but all its submodules work well, then the bug should be in the module.

![](example/complex.png)


---
## Example: Finding proximate squared root

Given an integer `Y`, what is the proximate value of `X` that satisfy `Y = X^2`?

**Gradient descent (GD)**: to minimize some function by iteratively moving in the direction of steepest descent as defined by the negative of the gradient.
<p align="center">
<img src="https://ml-cheatsheet.readthedocs.io/en/latest/_images/gradient_descent_demystified.png" width=400></img><br/>
<i>Image borrowed from <a href="https://ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html">ML glossary</a></i>
</p>

Here we use the GD algorithem to minimize `Y - X^2` and obtain a proximate `X`.

---
## Example: Finding proximate squared root (Cont'd)

#### The code

```python
def solve(y_expected, limit, step_size, steps, x=None):
    if not x: x = random.randint(1, 1000)
    y_current = calculate_Y(x)
    diff = y_expected - y_current
    i = 0
    while abs(diff) >= limit and i < steps:
        x = update_X(y_expected, y_current, x, step_size)
        y_current = calculate_Y(x)
        diff = y_expected - y_current
        # print('current x: {}, abs(diff): {}'.format(x, abs(diff)))
        i += 1
    return x

def calculate_Y(x): 
    return x * x

def update_X(y_expected, y_current, x, step_size):
    return x - (-2 * x * step_size)

if __name__ == '__main__':
    main()
```
---

## Example: Buttom-up debugging (manual)


Updating rule: X = X - d|y_expected - x^2| / dx * step_size

In Python shell, execute these to perform the test.

```python
import simple_gd_sqrt as sqrt_test


# Test calculate_Y
assert sqrt_test.calculate_Y(x=3) == 9
assert sqrt_test.calculate_Y(x=-3) == 9


# Test update_X
updated_X = sqrt_test.update_X(y_expected=9, y_current=4, x=2, step_size=0.0001)
assert updated_X == 2 + 2 * 2 * 0.0001
updated_X = sqrt_test.update_X(y_expected=9, y_current=16, x=4, step_size=0.0001)
assert updated_X == 4 - 2 * 4 * 0.0001


# Test solve
y_current = sqrt_test.solve(x=10, y_expected=9, limit=0.01, step_size=0.0001)
assert abs(y_current - 3) < 0.01
y_current = sqrt_test.solve(x=1, y_expected=9, limit=0.01, step_size=0.0001)
assert abs(y_current - 3) < 0.01
```

---
## Example: Buttom-up debugging (automatic)

Run `python -m pytest [script] to perform the automatic test.`

```python
import unittest
import simple_gd_sqrt as sqrt_test

class TestgdSQRT(unittest.TestCase):
    
    def test_solve(self):
        y_current = sqrt_test.solve(x=10, y_expected=9, limit=0.01, ...)
        self.assertTrue(abs(y_current - 3) < 0.01)
        y_current = sqrt_test.solve(x=1, y_expected=9, limit=0.01, ...)
        self.assertTrue(abs(y_current - 3) < 0.01)

    def test_calculate_Y(self):
        self.assertEqual(sqrt_test.calculate_Y(x=3), 9)
        self.assertEqual(sqrt_test.calculate_Y(x=-3), 9)

    def test_update_X(self):
        updated_X = sqrt_test.update_X(y_expected=9, y_current=4, x=2, ...)
        self.assertEqual(updated_X, 2 + 2 * 2 * 0.0001)
        updated_X = sqrt_test.update_X(y_expected=9, y_current=16, x=4, ...)
        self.assertEqual(updated_X, 4 - 2 * 4 * 0.0001)

if __name__ == '__main__':
    unittest.main()
```

---

## Example: Buttom-up debugging (troubleshooting)

Where is the bug? or which function you should check first?

```text
============================ short test summary info ============================
FAILED example/simple_gd_sqrt_pytest.py::TestgdSQRT::test_solve 
- AssertionError: False is not true
FAILED example/simple_gd_sqrt_pytest.py::TestgdSQRT::test_update_X 
- AssertionError: 4.0008 != 3.9992
========================== 2 failed, 1 passed in 0.23s ============================
```

See the function call graph.

<p align="center">
<img src="example/simple.png" height=250></img>
</p>

---
## Example: Bug fixing

#### Bottom-up debugging

Since `solve` depends on `update_X`, we should check `update_X` first.

##### The current implementation

```python
def update_X(y_expected, y_current, x, step_size):
    return x - (-2 * x * step_size)
```

Issue found: The gradient should be `2 * x * step_size` when `y_expected < X^2`.

##### Reimplement the function

```python
def update_X(y_expected, y_current, x, step_size):
    diff = y_expected - y_current
    if diff >= 0:
        return x - (-2 * x * step_size)
    else:
        return x - (2 * x * step_size)
```

---
## Example: Bug fixing (recheck)

#### Retest 

Command: `python3 -m pytest example/simple_gd_sqrt_test.py`

```text
============================== test session starts ==============================
platform darwin -- Python 3.9.6, pytest-7.0.1, pluggy-1.0.0
rootdir: /Users/chonghui/GitHub/talk-top-down-programming
collected 3 items

example/simple_gd_sqrt_pytest.py ...[100%]

3 passed in 0.01s
```

#### Calculate sqrt:
- `python3 example/simple_gd_sqrt.py 2`
- `python3 example/simple_gd_sqrt.py 3`
- `python3 example/simple_gd_sqrt.py 64`
- `python3 example/simple_gd_sqrt.py 10000`

All good!

---

<p>
<br/><br/><br/><br/><br/><br/><br/><br/>
<h1 align="center">Thank you for your attention!</h1>
<br/><br/><br/><br/><br/><br/>
</p>

- The slides: https://www.huichong.me/talks/top-down-programming/#1
- The code: https://github.com/AdeBC/talk-top-down-programming
