# Top-down programming for problem solving

&nbsp;

&nbsp;

&nbsp;

<div style="text-align: center"><b>Hui Chong</b><br/><br/>
Email: <a href="mailto:huichong.me@gmail.com">huichong.me@gmail.com<a><br/>
Website: <a href="https://www.huichong.me">https://www.huichong.me</a>
</div>

&nbsp;

&nbsp;

<div style="text-align: right">May 9, 2022<br/>
Big Data Biology Lab, <br/>
Institute of Science and Technology for Brain-inspired Intelligence, <br/>
Fudan University
</div>
---
## Programming for problem solving

### Why programming?

Problem solving generally replies on manual operations and automations.

Programming is a straightforward way to automate a process.

#### Manual operation

- **Flexible**: human can adapt to different problems.
- **Error prone**: human can make random mistakes.
- Manual operation is more for **exploration of finding a solution**.

#### Programming

- **Program**: some pre-defined instructions to be executed by computers.
- **Less flexible**: a program is only built for one problem.
- **More controllable**: even random process in computers can be controlled very well by setting a random seed.
- Program is more for **execution of the solution**.

---
## Top-down programming & bottom-up testing

### What are the benefits?

- Clear code structure that is easy to understand by others.
- Coding is also a kind of commuication (e.g., collaborative developing).
- Easier to debug.
- Develop and test more efficiently without almost any extra cost.
- Top-down programming is independent of programming language. 


### How it works? 

- Break each problem into multiple sub-problems.
- Solve each sub-problem independently.
- Then, assemble solutions to these sub-problems from the bottom-up.

---


## Function call graph

Function call graph can clearly show the structure of you program.

![](example/complex.png)

The example was generated by the [PyCallGraph](https://pycallgraph.readthedocs.io/en/master/index.html) package.

---
## Top-down programming

- Think about the structure while/before you start coding.
- The main function goes on the top so that any new comer can see the structure of the script (like a **table of content**).
- Run `main()` inside `if __name__ == '__main__'` statement for easier test.
  - `main()` function will not be executed if you're importing the script.

```python
def main():
    A(xxx)
    B(xxx)
    C(xxx)

def A(xxx):
    D(xxx)
    E(xxx)

......

def I(xxx):
  ......

if __name__ == '__main__':  
    main()
```

Programming is also about testing...

---

## Buttom-up testing and troubleshooting

**Buttom-up testing**: Assemble each submodule from the bottom-up.

```python
import script as test_funcs

expected_outputs = ...

assert test_funcs.D() == expected_outputs.D
assert test_funcs.E() == expected_outputs.E
assert test_funcs.A() == expected_outputs.A

assert test_funcs.F() == expected_outputs.F
assert test_funcs.G() == expected_outputs.G
assert test_funcs.B() == expected_outputs.B

assert test_funcs.H() == expected_outputs.H
assert test_funcs.I() == expected_outputs.I
assert test_funcs.C() == expected_outputs.C

assert test_funcs.main() == expected_outputs.main
```

**Troubleshooting**: The function that fails the test is the function with bug.

---

## Unittest and troubleshooting

**Unittest**: Test all functions automatically (in any order).

```python
import unittest
import script as test_funcs


class TestgdSQRT(unittest.TestCase):
    
    def test_main(self):
        ...

    def test_A(self):
        ...

    def test_B(self):
        ...

    ...
```

**Troubleshooting**: If a module cannot work but all its submodules work well, then the bug should be in the module.

---

## Example: Finding proximate squared root

Given an integer `Y`, what is the proximate value of `X` that satisfy `Y = X^2`?

**Gradient descent (GD)**: to minimize some function by iteratively moving in the direction of steepest descent as defined by the negative of the gradient.
<p align="center">
<img src="https://ml-cheatsheet.readthedocs.io/en/latest/_images/gradient_descent_demystified.png" width=400></img><br/>
<i>Image borrowed from <a href="https://ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html">ML glossary</a></i>
</p>

Here we use the GD algorithem to minimize `Y - X^2` and obtain a proximate `X`.

---
## Example: Finding proximate squared root (Cont'd)

#### The code

```python
def main():
    ......

def solve(y_expected, limit, step_size, steps, x=None):
    if not x: x = random.randint(1, 1000)
    y_current = calculate_Y(x)
    diff = y_expected - y_current
    i = 0
    while abs(diff) >= limit and i < steps:
        x = update_X(y_expected, y_current, x, step_size)
        y_current = calculate_Y(x)
        diff = y_expected - y_current
        i += 1
    return x

def calculate_Y(x): 
    return x * x

def update_X(y_expected, y_current, x, step_size):
    return x - (-2 * x * step_size)

if __name__ == '__main__':
    main()
```
---

## Example: Buttom-up testing

Run `python3 example/simple_gd_sqrt_mtest.py` to perform the test.

```python
import simple_gd_sqrt as sqrt_test


# Test calculate_Y
assert sqrt_test.calculate_Y(x=3) == 9
assert sqrt_test.calculate_Y(x=-3) == 9


# Test update_X
# Updating rule: X = X - d|y_expected - x^2| / dx * step_size
updated_X = sqrt_test.update_X(y_expected=9, y_current=4, x=2, step_size=0.0001)
assert updated_X == 2 + 2 * 2 * 0.0001
updated_X = sqrt_test.update_X(y_expected=9, y_current=16, x=4, step_size=0.0001)
assert updated_X == 4 - 2 * 4 * 0.0001


# Test solve
y_current = sqrt_test.solve(x=10, y_expected=9, limit=0.01, step_size=0.0001)
assert abs(y_current - 3) < 0.01
y_current = sqrt_test.solve(x=1, y_expected=9, limit=0.01, step_size=0.0001)
assert abs(y_current - 3) < 0.01
```

---

## Example: Troubleshooting based on bottom-up testing

Run `python example/simple_gd_sqrt_mtest.py` to perform the test.

```text
Traceback (most recent call last):
  File "/Users/chonghui/GitHub/talk-top-down-programming/example/simple_gd_sqrt_mtest.py", 
  line 13, in <module>
    assert updated_X == 4 - 2 * 4 * 0.0001
AssertionError
```

**Recall** "_The function that fails the test is the function with bug_".

So, the bug should be in `update_X` (**where the test fails**).



<p align="center">
<img src="example/simple.png" height=250></img>
</p>

---
## Example: Unittest

Run `python -m pytest [script]` to perform the automatic test.

```python
import unittest
import simple_gd_sqrt as sqrt_test

class TestgdSQRT(unittest.TestCase):
    
    def test_solve(self):
        y_current = sqrt_test.solve(x=10, y_expected=9, limit=0.01, ...)
        self.assertTrue(abs(y_current - 3) < 0.01)
        y_current = sqrt_test.solve(x=1, y_expected=9, limit=0.01, ...)
        self.assertTrue(abs(y_current - 3) < 0.01)

    def test_calculate_Y(self):
        self.assertEqual(sqrt_test.calculate_Y(x=3), 9)
        self.assertEqual(sqrt_test.calculate_Y(x=-3), 9)

    def test_update_X(self):
        updated_X = sqrt_test.update_X(y_expected=9, y_current=4, x=2, ...)
        self.assertEqual(updated_X, 2 + 2 * 2 * 0.0001)
        updated_X = sqrt_test.update_X(y_expected=9, y_current=16, x=4, ...)
        self.assertEqual(updated_X, 4 - 2 * 4 * 0.0001)

if __name__ == '__main__':
    unittest.main()
```

---

## Example: Troubleshooting based on Unittest

Where is the bug? or which function should we check first?

```text
============================ short test summary info ============================
FAILED example/simple_gd_sqrt_pytest.py::TestgdSQRT::test_solve 
- AssertionError: False is not true
FAILED example/simple_gd_sqrt_pytest.py::TestgdSQRT::test_update_X 
- AssertionError: 4.0008 != 3.9992
========================== 2 failed, 1 passed in 0.23s ============================
```

**Recall** "_If a module cannot work but all its submodules work well, then the bug should be in the module_".

See the function call graph.

<p align="center">
<img src="example/simple.png" height=250></img>
</p>

---
## Example: Bug fixing


Since `solve` depends on `update_X`, we should check `update_X` first.

##### The current implementation

```python
def update_X(y_expected, y_current, x, step_size):
    return x - (-2 * x * step_size)
```

##### Issue found

The gradient of `Y - X^2` should be 
- `-2 * x` **when** `y_expected >= X^2`
- `2 * x` when `y_expected < X^2`

##### Reimplement the function

```python
def update_X(y_expected, y_current, x, step_size):
    diff = y_expected - y_current
    if diff >= 0:
        return x - (-2 * x * step_size)
    else:
        return x - (2 * x * step_size)
```

---
## Example: Bug fixing (recheck)

#### Retest 

Command: `python -m pytest example/simple_gd_sqrt_test.py`

```text
============================== test session starts ==============================
platform darwin -- Python 3.9.6, pytest-7.0.1, pluggy-1.0.0
rootdir: /Users/chonghui/GitHub/talk-top-down-programming
collected 3 items

example/simple_gd_sqrt_pytest.py ...[100%]

3 passed in 0.01s
```

#### Calculate sqrt:
- `python3 example/simple_gd_sqrt.py 2`
- `python3 example/simple_gd_sqrt.py 3`
- `python3 example/simple_gd_sqrt.py 64`
- `python3 example/simple_gd_sqrt.py 10000`

All good!

---

<p>
<br/><br/><br/><br/><br/><br/><br/><br/>
<h1 align="center">Thank you for your attention!</h1>
<br/><br/><br/><br/><br/>
<h4 align="center">Please share it with your friends if you think this could help them! </h5>
</p>

- The slides: https://www.huichong.me/talks/top-down-programming/#1
- The code: https://github.com/AdeBC/talk-top-down-programming

